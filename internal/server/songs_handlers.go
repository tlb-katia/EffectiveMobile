package server

import (
	"EffectiveMobile_Project/internal/entities"
	"EffectiveMobile_Project/internal/server/lib"
	"errors"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/render"
	"io"
	"log/slog"
	"net/http"
	"strconv"
	// docs is generated by Swag CLI, you have to import it.
)

// GetAllSongsFiltered Getting all songs by filter
// @Summary get all songs in the list by filter
// @Tags Songs
// @Accept json
// @Produce json
// @Param limit query int false "Limit the number of results"
// @Param offset query int false "Offset for pagination"
// @Success 200 {array} []entities.AllSongsResponse
// @Failure 400 {object} lib.Response "Bad Request"
// @Failure 500 {object} lib.Response "Internal Server Error"
// @Router /all [get]
func (s *Server) GetAllSongsFiltered(w http.ResponseWriter, r *http.Request) {
	songReq := &entities.AllSongsRequest{}

	const op = "server.GetAllSongsFiltered"
	log := s.log.With(op, "method", r.Method, "path", r.URL.Path)

	if err := render.DecodeJSON(r.Body, songReq); err != nil {
		if errors.Is(err, io.EOF) {
			log.Error("request body is empty"+err.Error(), log.With("op", op))
			render.JSON(w, r, lib.Resp(http.StatusBadRequest, "request body is empty"))
			render.Status(r, http.StatusBadRequest)
			return
		}
		log.Error("Failed to decode request: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusBadRequest, "Failed to decode request"))
		render.Status(r, http.StatusBadRequest)
		return
	}

	songReq.Offset, songReq.Limit = s.GetLimitAndOffset(r)

	resp, err := s.db.GetAllSongsFiltered(r.Context(), songReq)
	if err != nil {
		log.Error("Failed to get all songs "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusInternalServerError, "Internal server error"))
		render.Status(r, http.StatusInternalServerError)
		return
	}

	if resp == nil {
		log.Warn("No response for songs filtered for request", log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusOK, "Requested songs not found"))
	}

	log.Info("all songs are successfully displayed", log.With("op", op))
	render.JSON(w, r, resp)
}

func (s *Server) GetLyricsPaginated(w http.ResponseWriter, r *http.Request) {
	const op = "server.GetLyricsPaginated"
	log := s.log.With(op, "method", r.Method, "path", r.URL.Path)

	req := &entities.LyricsRequest{}
	if err := render.DecodeJSON(r.Body, req); err != nil {
		if errors.Is(err, io.EOF) {
			log.Error("request body is empty"+err.Error(), log.With("op", op))
			render.JSON(w, r, lib.Resp(http.StatusBadRequest, "request body is empty"))
			return
		}
		log.Error("Failed to decode request: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusBadRequest, "Failed to decode request"))
		return
	}

	offset, limit := s.GetLimitAndOffset(r)
	req.Offset = offset
	req.Limit = limit

	resp, err := s.db.GetLyricsPaginated(r.Context(), req)
	if err != nil {
		log.Error("Failed to get lyrics "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusInternalServerError, "Internal server error"))
		return
	}

	if resp == nil {
		log.Warn("No response for lyrics filtered for request", log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusOK, "Requested lyrics not found"))
		return
	}

	log.Info("lyrics are successfully displayed", log.With("op", op))
	render.JSON(w, r, resp)
}

func (s *Server) DeleteSong(w http.ResponseWriter, r *http.Request) {
	const op = "server.DeleteSong"
	log := s.log.With(op, "method", r.Method, "path", r.URL.Path)

	songIdStr := chi.URLParam(r, "id")
	songId, err := strconv.Atoi(songIdStr)
	if err != nil {
		log.Error("Failed to convert songId to int: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusBadRequest, "Failed to convert songId to int"))
		return
	}

	err = s.db.DeleteSong(r.Context(), songId)
	if err != nil {
		log.Error("Failed to delete song: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusInternalServerError, "Internal server error"))
		return
	}

	log.Info("Successfully deleted a song", slog.With("songId"), songId)
	render.JSON(w, r, lib.Resp(http.StatusOK, "Successfully deleted a song"))
}

func (s *Server) ChangeSongData(w http.ResponseWriter, r *http.Request) {
	const op = "server.ChangeSongData"
	log := s.log.With(op, "method", r.Method, "path", r.URL.Path)

	songIdStr := chi.URLParam(r, "id")
	songId, err := strconv.Atoi(songIdStr)
	if err != nil {
		log.Error("Failed to convert songId to int: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusBadRequest, "Failed to convert songId to int"))
		return
	}

	req := &entities.ChangeSongReq{}
	if err := render.DecodeJSON(r.Body, req); err != nil {
		if errors.Is(err, io.EOF) {
			log.Error("request body is empty"+err.Error(), log.With("op", op))
			render.JSON(w, r, lib.Resp(http.StatusBadRequest, "request body is empty"))
			return
		}
		log.Error("Failed to decode request: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusBadRequest, "Failed to decode request"))
		return
	}

	req.Id = uint64(songId)

	resp, err := s.db.ChangeSongData(r.Context(), req)
	if err != nil {
		log.Error("Failed to change song: "+err.Error(), log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusInternalServerError, "Internal server error"))
		return
	}
	if resp == nil {
		log.Warn("No response for song", log.With("op", op))
		render.JSON(w, r, lib.Resp(http.StatusOK, "Requested song not found"))
		return
	}

	log.Info("Successfully changed a song", log.With("songId"), songId)
	render.JSON(w, r, resp)
}

//func (s *Server) AddSong(w http.ResponseWriter, r *http.Request) {
//	const op = "server.AddSong"
//	log := s.log.With(op, "method", r.Method, "path", r.URL.Path)
//
//}
